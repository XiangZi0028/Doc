### shared_ptr和unique_ptr

#### 使用方法：

| shared_ptr<T> p          | 创建一个空智能指针，可以指向一个T类型的对象     |
| ------------------------ | ----------------------------------------------- |
| shared_ptr<T> sp         | 创建一个空智能指针，可以指向一个T类型的对象     |
| unique_ptr<T> up         | 创建一个空智能指针,   可以指向一个T类型的对象   |
| p                        | 将p用作一个 判断条件，若p指向一个对象，则为true |
| *p                       | 解引用p，获得p指向的对象                        |
| p->mem                   | 这个操作相当于*p.mem，mem为T的成员              |
| p.get()                  | 返回p中保存的T类型对象的指针                    |
| swap(p,q) 或者 p.swap(q) | 交换p和q中的对象的指针                          |

#### shared_ptr

shared_ptr允许多个指针指向同一个对象.shared_ptr只负责管理对象的生命周期,当shared_ptr进行拷贝或者赋值操作时,每个shared_ptr都会记录有多少个其他shared_ptr指向当前对象.其实可以理解为每个shared_ptr都有一个关联的计数器,无论何时我们拷贝一个shared_ptr的时候都会导致计数器递增,当我们给shared_ptr赋予一个新的值或者是shared_ptr被销毁(例如一个局部的shared_ptr离开其作用域)的时候,计数器就会递减.一旦一个shared_ptr的计数器变为0,他就会自动释放他自己所管理的对象.

,

(1) make_shared :此函数动态分配一个对象并初始化它,返回指向分配的对象的shared_ptr.

使用方法如下:make_shared<int>(2),在调用make_shared时,传递的参数必须要能用来初始化一个int类型,如果我们什么也不填,那么对象就会进行值初始化.

### weak_ptr