## 关键字

### alignas

指定字节对齐的方式

### alignof

查看时几个字节对齐

atomic_noexcept

atomic_cancel

atomic_commit

### auto

自动推导类型

### decltype

自动推导类型、为什么又了auto还要又decltype，因为我们需要获得一个函数的返回值的类型但是又不想执行该函数时需要用decltype

### default

告诉编译器生成默认的构造函数

当我们不在类里面定义构造函数的时候，编译器会默认给我们生成默认构造函数，如果我们定义了默认构造或者拷贝构造函数之后编译器就不会为我们生成、但是我们可以通过default来告诉编译器给我们生成默认构造

### delete

当我们不希望类被赋值或者某些操作的时候我们可以通过delete删除，告诉编译器不要为我们生成

### dynamic_cast

用于动态类型转换，只能用于含有虚函数的类。用于类层次间的向上和向下转换。只能转指针或引用。向下转化时，如果是非法的，指针返回null，引用抛异常。

向下转化：

子类向基类的转化

向上转化：

基类向子类的转化

它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。

### const_cast

把const转换为非const

### static_cast

把非const转换为const

### reinterpert_cast

什么都可以转，重新对内存进行说明？

### explicit

explicit主要是用来修饰构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。类构造函数默认情况下声明为implicit。

​	使用：

​		只能用于类内部的构造函数声明上，而不能在外部类函数(实现)上定义，作用是第一个参数不能进行隐士转换，也就是说只适用于单个参数的构造函数，或者多个参数的构造函数，但是除开第一个参数之外的其它参数必须要有默认值。

```c++
class ZString{
    explicit ZString(int n){};
    ZString(const char *p){};
}

test
```



隐式转换：

​	可以由单个实参来调用的构造函数定义了一个从形参类型到该类类型的隐式转换。编译器在试图编译某一条语句的时候，如果某个函数的参数类型不匹配，编译器就会尝试进行隐士转换，如果隐式转换之后能正确编译，编译器就会继续编译了。

### extern

告诉编译器这是一个外部变量，比如我们定义一个全局变量a，但是这个变量只能够在定义这个变量的cpp可以看见，我们可以在要使用这个变量的其它cpp中声明extern、告诉编译器这个变量是一个外部变量

### friend

​	在定义一个类的时候，可以把一些函数（包括全局函数和其他类的成员函数）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。

​	比如类A希望用到类B的函数的时候，需要在类A中声明类B为友元函数

### goto 

语句的跳转，避免使用吧，可读性太差

### inline

内联函数、在使用该函数的地方直接展开

### mutable

​	mutable是为了突破const关键字的限制，如果一个类中的成员函数fun被定义为const，则表示告诉编译器不会修改类中的成员变量，如果修改编译器会报错，但是如果一个变量被声明为mutable的话，在const的成员函数中依然可以被修改。

### noexcept

​	告诉编译器我不会抛出异常、告诉调用者我不会与抛出异常。如果还依然非要try的话 什么也catch不到

nullptr

### thread_local

每个线程都有其自己的副本，当通过名称引用它时，将使用当前线程关联的副本。

### volatile

告诉编译器不要对volatile变量做优化、执行顺序等

### override

告诉编译器要重写父类的函数

### final

所有继承当前类的子类，不再能对该虚函数惊醒重写

### tuple 和pair

## 各种排序：

### 1.冒泡排序

每次相邻的两个进行比较、如果前一个大于后一个就交换    n^2

### 2.插入排序

序列分为两个部分，分为有序和无序，每次从无序中取一个插入到有序序列中

### 3.选择排序

序列分为两个部分，有序和无序，找出无序数列中最小的那个

### 4.快排

递归，以找一个标杆，让标杆的左边都小于标杆，标杆的右边都大于标杆，然后在标杆的两边分别执行上述操作

### 5.归并排序

分治的方法，递归。把数据分成两份，每份再拆成两份，直到不能再分，先局部排序，然后再整体有序

### 6.堆排序 

大根堆：根节点大于两个子节点

小根堆：根阶段小于两个子节点

7.桶排序

8.计数排序

9.基数排序

### 10.希尔排序

分组排序，100个数据先分成n份

然后分别对((100/n)*(i-1),(100/n)*i)进行排序，完成之后再把n变成2n

