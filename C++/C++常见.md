#### 智能指针

unique_ptr:

实现独占式拥有概念，保证再同一时间内之哟袷智能指针能访问该对象，对于避免资源泄露特别好用。正因为独占的原因，我们不能拷贝unique_ptr，但是如果unique_ptr是一个将亡值的话可以拷贝(比如用作返回值)

shared_ptr:

实现共享，一个资源可以被多个指针共享，用计数来表明某个资源被多少个指针共享，可以用use_count()来查看资源的所有者额数，除了可以通过new来构造，还可以用unique和weak，auto来构造。当我们调用release()，当前指针会释放资源的所有权。

不要用get的指针初始化一个shared指针

weak_ptr:

一种不控制对象声明周期的只能指针，指向一个shared_ptr所管理的对象，设计他的目的是配合shared_ptr的工作，只能从一个shared_ptr或者另外一个weak进行构造。比如有时候有些数据我们只想给别人用，但是我不希望因为他再用我就不能删除这些数据。

同时解决shared_ptr相互引用的死锁问题

#### C++内存分配

栈：由编译器管理分配和回收，存放局部变ᰁ和函数参数。

堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。

全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。

常量存储区：存储常量，⼀般不允许修改。

代码区：存放程序的⼆进制代码。

#### 参数传递

值传递和址传递

指针和引用作为参数

指针参数：记录传递进来的值(地址)

引用：创建临时变量，但是临时变量记录的是地址

#### const

修饰基本数据类型：表示这些数据是常量不能被改变

修饰指针：const在*号左侧表示指针指向的对象的值不能变

​					const在*号右侧表示指针本身不呢个变

修饰引用：表示不能通过该引用来改变对象的值

应用到函中：被const修饰的在函数内不能被改变，如果返回const的指针或者引用会按照修饰原则进行修饰



修饰类：

修饰类成员变量：只在某个生命周期内是常量，不能在类的变量生命中用const修饰，因为编译器不知道const变量的值是什么，应该在构造函数的初始化列表中进行。

修饰成员函数：被const修饰的函数不能修改对象的内容，const和static不能同时对成员函数使用，如果非要改变，就要把要改变的变量用mutable修饰。因为static函数无this指针，但是const必须具体到某个函数。

修饰类的对象：常量对象只能调用常量函数，不能调用其它函数

#### static

修饰局部变量：一般情况下局部变量在栈区；static修饰的局部变量放在静态数据区，一直延续到整个程序结束，但是作用域没有变。

修饰全局变量：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。

修饰函数：和修改全局变量类似，只是改变了作用域

修饰类成员变量：表示该变量所有对象只有一个副本，可以通过类名、对象去访问

修饰类成员函数：表示该类属于一个类，而不是属于特定的对象

静态⾮常量数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已

#### class和struct

C++中，class和struct的不同在于class的默认成员访问权限和继承权限都是private，struct的都是public

C中的struct没有成员函数，且无原先访问改了

#### 重载重写重定义

重载：函数名相同、参数可以不同

重写：virtual

重定义：非virtual，返回值和参数都可以不同

#### 构造函数

###### 无参构造函数

即默认构造函数，不写的话编译器会⾃动⽣成默认构造函数，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数

###### 一般构造函数

也称重载构造函数，一般有多种形式，参数不同

###### 拷贝构造函数

为对象本身的引用，用于根据一个已存在的对象复制一个新的对象，一般函数就是一一赋值成员变量，编译器会默认生成拷贝构造函数，但是最好不要用，如果类成员中有指针就比较麻烦了

<img src="E:\Document\C++\pic\image-20220317165843402.png" alt="image-20220317165843402" style="zoom:150%;" />

###### 移动构造函数

###### 赋值运算符重载

重载操作符=，一般情况下会返回自身类型的引用。实现连等

```
A a1,12;a1=a2;//运用赋值运算符
A a3=a1;//运用拷贝构造
```

#### 虚函数

⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。

实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。

后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多

态。

**补充**：如果基类中没有定义成 virtual，那么进⾏ Base B; Derived D; Base *p = D; p-\>function(); 这种情况下调⽤的则是 Base 中的 function()。因为基类和派⽣类中都没有虚函数的定义，那么编译器就会认为不⽤留给动态多态的机会，就事先进⾏函数地址的绑定（早绑定），详述过程就是，定义了⼀个派⽣类对象，⾸先要构造基类的空间，然后构造派⽣类的⾃身内容，形成⼀个派⽣类对象，那么在进⾏类型转换时，直接截取基类的部分的内存，编译器认为类型就是基类，那么（函数符号表［不同于虚函数表的另⼀个表］中）绑定的函数地址也就是基类中函数的地址，所以执⾏的是基类的函数。

#### 字节对齐

对于结构体中的各个成员，第⼀个成员位于偏移为 0 的位置，以后的每个数据成员的偏移量必须是 min(#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。

在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是min(#pragma pack()制定的数，⻓度最⻓的数据成员的⻓度) 的倍数

#### 动态链接和静态链接

#### 设计一个类只能静态分配

重载new、delete运算符为private属性

#### 设计一个类只能动态分配

把类的析构函数和构造设置厚protected，再用子类来动态创建

#### i++和++i

![image-20220317172311795](E:\Document\C++\pic\image-20220317172311795.png)

#### 斐波那契数列

每个数字等于前两个数字之和

0 1 1 2 3 5 8 ....

1.暴力递归   时间2^n 

2.去重递归	时间n  空间 n

3.双指针迭代 只需要2个值保存 就不需要递归了 

#### 硬币排列

n枚硬币排成阶梯状 可以排出几个完整的阶梯

#### 判断是否有环
