### GPU渲染流水线	

​		今天主要说一下GPU硬件渲染管线，准确来说是GPU渲染流水线，再不回忆一下就忘了，顺便写文章练练手。主要是说明一下CPU数据到屏幕上呈现的结果，都经历了哪些步骤，他们分别又有什么意义。本篇文章主要是回忆半年前所学的东西，仅仅是自己的一些理解，不保证完全正确，仅供参考。（以OpenGL为例）

​		action！不用说了吧，数据肯定是先加载到内存中，也就是这段时间数据都在应用层中，之后我们要通过图形API，把数据送到GPU中，下面一OpenGL为例。

<img src="C:\Users\WellLink-ZZX\AppData\Roaming\Typora\typora-user-images\image-20220314173249836.png" alt="image-20220314173249836" style="zoom: 80%;" />

```c++
glGen*() //
glBind*() //
glBufferData() //
```

​		OpenGL它是隐式图形API，我们不知道这些API内部到底干了些什么，或许经过这3步操作之后数据也并没有写到GPU缓存中去。或许底层驱动的实现会根据 `glBufferData(GLenum target, GLsizeiptr size, const void *data, GLenum usage) `的最后一个参数usage来决定数据存储的位置，以及数据什么时候被写如到GPU缓存中去。

![image-20220314173933026](C:\Users\WellLink-ZZX\AppData\Roaming\Typora\typora-user-images\image-20220314173933026.png)

​		在应用程序中我们还要负责对数据进行解释。举个例子吧，如下图所示，每一行代表一个顶点，也就是一共有6个顶点，每个顶点包含了它的pos、uv、normal三个数据，总共n个浮点数，如果我们不对这些数据进行说明，那你的流水线输入头也不知道该如何来定义这些数据，他就只能按照它自己的理解来进行解释了。但是这不一定是我们想要的结果，所以我们需要在应用程序中自己组织这些数据，比如那几个数表示的是pos，哪几个点表示的是uv，哪几个点表示的normal。明确这些意义之后我们就可以很好的解释vertexBuffer中的数据了。如下所示：

![image-20220314174538005](C:\Users\WellLink-ZZX\AppData\Roaming\Typora\typora-user-images\image-20220314174538005.png)

​		当我们需要的所有数据都已经准备完毕之后，我们的渲染流水线也就可以开始了。大致流程如下：

![image-20220314183245030](C:\Users\WellLink-ZZX\AppData\Roaming\Typora\typora-user-images\image-20220314183245030.png)

​		首先我们的数据依次的进入到我们的顶点着色器中，一般情况下我们在顶点着色器中会进行三种变换，也就是模型变换、视图变换和投影变换。这是为了模型的坐标转移到GL的世界坐标系中去。以前的固定管线中，顶点着色器和片段着色器以及几何着色器是没有被开放出来的，到了可编程管线的时候，顶点着色器才被开放出来，固定管线我也没有用过。

​		问题来了，这些经过顶点着色器冲洗的顶点就是一个点呀，最终我们要在屏幕上看到的肯定不能是这么一个一个的点呀，所以下一步我们就要把这些数据按照我们的在应用程序中的设置给组装起来，在应用程序中我们会调用`glDrawArrays(GLenum mode, GLint first, GLsizei count)`或者`glDrawElements(GLenum mode, GLsizei count, GLenum type, const void *indices)`来发起绘制命令，其中第一个参数就是mode就是指定图元的类型。可以是点、线、三角形等。

​	以图元是三角形为例，那么现在我们就拿到了三个点Vertex[0]、Vertex[1]、Vertex[2]，这三个点会组成一个平面，之后我们会进行平面进行裁剪，裁剪的主要目的也是说减少计算吧，对于哪些不在GL [-1,1]^3空间中的部分，或者处于物体背面看不见的部分(`glEnable(GL_CULL_FACE)`)，我们的流水线也没有必要对它进行加工，如果不进行裁剪，那比如所有的三角形都在可视空间之外，那我们的GPU就可以闲置休息，没必要做无用功。平面经过裁剪剩下的部分是我们最终需要渲染的部分，那么我们如何把这个平面转化成我们屏幕上的点呢。大家经常所说的光栅化就来了。

​	首先是屏幕映射，也就是把每个点映射到屏幕上去。这里后面我会用我写的软渲染器的代码来进行描述。经过屏幕映射之后又进行了三角形的设置。也许你会感到好奇，为什么这里又要进行图元的设置。

![image-20220314181742049](C:\Users\WellLink-ZZX\AppData\Roaming\Typora\typora-user-images\image-20220314181742049.png)

​		根据上图所示有两个经过各种变换三角形平面，从图2中我们可以看到上面的三角形有一个顶点会落到屏幕之外，之前我们说到，流水线中会对三角平面进行裁剪，裁剪之后如果我们补重新设置三角形的话，那么将会如图4所示，所有这也是我认为此次图元设置的意义是什么。时候我们要进行三角形遍历。

​		遍历的内容主要是我们映射到屏幕上的像素点，每个像素点都会经过片段着色器，片段着色器和顶点着色器一样，需要我们自己来编写shader，在片段着色器中我们可以计算每个点的光照，也就是最终呈现到我们平屏幕上的颜色。这些像素会经过各种测试，比如深度测试(`glEnable(GL_DEPTH_TEST)`)，只有通过深度测试的点才会经过片段着色器的洗礼。片段着色器进行光照结束之后，这些值会写入到我们的帧缓冲区或者我们的RenderTarget渲染目标上。这基本上就是GPU渲染流水线的整个流程。

​		其实除了上面所展示的这些过程之外，还有一些其它的不是必须的部分，比如在顶点着色器之后还可能有细分着色器，几何着色器。细分着色器的主要目的是。。。。。，几何着色器主要的任务是。。。。。。

#### 软光栅化器

​	之前写这个软光栅化器的目的主要是为了模拟GPU的渲染流水线，加深自己的学习吧。

​	